---
Status: true
tags:
  - atividades_fadex
Solicitante: 1.17.1 - Conta Própria
Data Conclusão: 2025-02-05T12:32
Data de Início: 2025-02-03T14:02
---

## Sumário
1. [Módulo de Projetos em Execução](#módulo-de-projetos-em-execução)
2. [Módulo de Monitoramento de Vigências](#módulo-de-monitoramento-de-vigências)
3. [Módulo de Gerenciamento de Arquivos](#módulo-de-gerenciamento-de-arquivos)
4. [Módulo de Dashboard dos Projetos](#módulo-de-graficos)

# 1 - Módulo de Projetos em Execução

### Visão Geral
O módulo de Projetos em Execução é implementado usando Streamlit e é responsável pela visualização e gerenciamento dos projetos ativos da FADEX. Este módulo fornece uma interface interativa para análise e acompanhamento de projetos.

### Componentes Principais

#### 1. Configuração da Página
```python
st.set_page_config(
    page_title="Projetos em Execução FADEX",
    page_icon="fadex.ico",
    layout="wide"
)
```
- Define o layout wide para melhor aproveitamento do espaço
- Configura título e ícone da página
- Remove elementos padrão do Streamlit para uma interface mais limpa

#### 2. Sistema de Cache
```python
@st.cache_data
def load_data(file_path, mtime):
    df = pd.read_excel(file_path, sheet_name='Planilha1', header=1)
    if df.columns[0].startswith("Unnamed"):
        df = df.iloc[:, 1:]
    return df
```
- Implementa cache de dados para otimizar carregamento
- Evita recarregamento desnecessário dos arquivos Excel
- Utiliza timestamp para invalidação do cache

#### 3. Transformação de Dados
```python
def transform_data(df):
    # Processamento de números do projeto
    if "Núm. Projeto" in df.columns:
        df["Núm. Projeto"] = pd.to_numeric(df["Núm. Projeto"], errors="coerce")
    
    # Processamento de datas
    colunas_data = [
        "Data de Vigência Inicial", "Data de Vigência Final",
        "Data de Vigência Inicial Atual", "Data de Vigência Atual Final"
    ]
    for col in colunas_data:
        if col in df.columns:
            df[col] = pd.to_datetime(df[col], errors="coerce")
            df[col] = df[col].dt.strftime("%Y-%m-%d")
```
- Padroniza formatos de dados
- Trata valores nulos e erros
- Converte tipos de dados para formatos apropriados

#### 4. Sistema de Filtros
- **Filtro de Orçamento**: Slider para seleção de faixa de valores
- **Filtro de Título**: Busca por texto no título do projeto
- **Filtro de Vigência**: Seleção de períodos específicos
- **Filtro de Conta Corrente**: Seleção múltipla de contas
- **Filtro de Responsável**: Seleção múltipla de responsáveis

#### 5. Cálculo de Status de Prazo
```python
def compute_status(date_str):
    if pd.isna(date_str):
        return "Vigência não cadastrada"
    dt = datetime.strptime(date_str, "%Y-%m-%d").date()
    today = date.today()
    days_diff = (dt - today).days
```
- Calcula diferença entre datas
- Formata mensagem de status
- Aplica estilização baseada no status

#### 6. Exportação de Dados
```python
def to_excel(df):
    output = BytesIO()
    with pd.ExcelWriter(output, engine="xlsxwriter") as writer:
        df.to_excel(writer, index=False)
        workbook = writer.book
        worksheet = writer.sheets["Projetos"]
        # Configuração de formatação
```
- Exporta dados filtrados para Excel
- Aplica formatação automática
- Configura largura das colunas

### Fluxo de Dados
5. Carregamento inicial dos dados do Excel
6. Transformação e limpeza dos dados
7. Aplicação de filtros selecionados
8. Atualização da visualização
9. Exportação quando solicitado

## Módulo de Monitoramento de Vigências

### Visão Geral
O módulo de Monitoramento de Vigências é responsável pelo acompanhamento dos prazos dos projetos, categorizando-os por nível de urgência e permitindo gestão de status.

### Componentes Principais

#### 1. Sistema de Categorização
```python
def categorize_deadline(vigencia_final):
    try:
        dt = datetime.strptime(vigencia_final, "%Y-%m-%d").date()
    except Exception:
        return "Data Inválida"
    
    today = date.today()
    diff = (dt - today).days
    
    if dt < today:
        return "PROBLEMA"
    elif diff <= 30:
        return "CRÍTICO"
    elif diff <= 60:
        return "ATENÇÃO"
    elif diff <= 90:
        return "MONITORAMENTO"
    else:
        return "REGULAR"
```
- Categoriza projetos baseado no prazo
- Define níveis de urgência
- Calcula diferença de datas

#### 2. Banco de Dados SQLite
```python
def update_project_status(conta_corrente, status_value, observation, updated_by, data_aditivo=None):
    updated_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    cursor.execute('''
        INSERT INTO project_status 
        (Conta_Corrente, status, observation, data_aditivo, updated_at, updated_by)
        VALUES (?, ?, ?, ?, ?, ?)
        ON CONFLICT(Conta_Corrente) DO UPDATE SET
            status=excluded.status,
            observation=excluded.observation,
            data_aditivo=excluded.data_aditivo,
            updated_at=excluded.updated_at,
            updated_by=excluded.updated_by
    ''', (conta_corrente, status_value, observation, data_aditivo_str, updated_at, updated_by))
```
- Armazena status dos projetos
- Mantém histórico de atualizações
- Gerencia conflitos de atualização

#### 3. Sistema de Filtros Específicos
- Filtro por Dupla do Projeto
- Filtro por Categoria de Urgência
- Filtro por Status Definido
- Filtro por Conta Corrente

#### 4. Gestão de Status e Observações
- Interface para atualização de status
- Campo para observações
- Registro de data de aditivo
- Controle de usuário responsável

### Fluxo de Trabalho
10. Carregamento dos dados do projeto
11. Categorização automática
12. Aplicação de filtros
13. Gestão de status
14. Atualização do banco de dados

## Módulo de Gerenciamento de Arquivos

### Visão Geral
O módulo de Gerenciamento de Arquivos fornece uma interface web para navegação e manipulação de documentos no servidor de arquivos da FADEX.

### Componentes Principais

#### 1. Sistema de Autenticação
```python
def verifica_acesso_rede(share, username, password, domain=''):
    user = f"{domain}\\{username}" if domain else username
    net_resource = (win32netcon.RESOURCETYPE_DISK, None, share, None)
    try:
        win32wnet.WNetAddConnection2(net_resource, password, user, 0)
        win32wnet.WNetCancelConnection2(share, 0, True)
        return True
    except pywintypes.error:
        return False
```
- Integração com autenticação Windows
- Gerenciamento de credenciais
- Controle de níveis de acesso

#### 2. Sistema de Arquivos
```python
def list_folder():
    entries = []
    for item in os.listdir(folder_path):
        full_path = os.path.join(folder_path, item)
        entry = {
            'nome': item,
            'path': full_path,
            'tipo': 'pasta' if os.path.isdir(full_path) else 'arquivo',
            'mod_date': datetime.fromtimestamp(os.path.getmtime(full_path)),
            'size': os.path.getsize(full_path) if os.path.isfile(full_path) else None
        }
        entries.append(entry)
```
- Listagem de arquivos e pastas
- Ordenação e filtros
- Gestão de metadados

#### 3. Upload e Download
```python
@app.route('/upload', methods=['POST'])
def upload_file():
    if not exige_acesso_completo():
        return redirect(url_for('list_folder'))
    
    file = request.files['file']
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        save_path = os.path.join(current_path, filename)
        file.save(save_path)
```
- Upload de arquivos
- Validação de tipos permitidos
- Gestão de nomes seguros

#### 4. Cesta de Downloads
```python
@app.route('/download_basket', methods=['POST'])
def download_basket():
    basket_data = request.form.get("basketData")
    basket_name = request.form.get("basketName") or "cesta"
    
    mem_zip = io.BytesIO()
    with zipfile.ZipFile(mem_zip, mode="w") as zf:
        for file_item in files:
            zf.write(file_path, arcname=file_name)
```
- Seleção múltipla de arquivos
- Compactação em ZIP
- Download em lote

#### 5. Sistema de Logs
```python
def log_action(level, message):
    extra = {
        "client_ip": request.remote_addr,
        "hostname": socket.gethostname()
    }
    logger.log(level, message, extra=extra)
```
- Registro de ações
- Rotação de logs
- Informações detalhadas

### Segurança

#### 1. Validação de Caminhos
```python
def is_allowed_path(target_path):
    normalized_base = os.path.abspath(BASE_DIR)
    normalized_target = os.path.abspath(target_path)
    return normalized_target.startswith(normalized_base)
```
- Previne acesso a diretórios não autorizados
- Normalização de caminhos
- Validação de permissões

#### 2. Criptografia de Credenciais
```python
def save_credentials_for_ip(ip, username, password, domain):
    key = load_key()
    fernet = Fernet(key)
    data_encrypted = fernet.encrypt(data_json.encode())
```
- Armazenamento seguro de credenciais
- Criptografia de dados sensíveis
- Gestão de chaves

#### 3. Headers de Segurança
```python
@app.after_request
def set_security_headers(response):
    response.headers['Content-Security-Policy'] = "default-src 'self';"
    response.headers['X-Frame-Options'] = 'DENY'
    response.headers['X-Content-Type-Options'] = 'nosniff'
```
- Proteção contra ataques comuns
- Políticas de segurança
- Controle de recursos

### Interface do Usuário

#### 1. Layout Responsivo
- Adaptação a diferentes tamanhos de tela
- Organização eficiente de elementos
- Feedback visual claro

#### 2. Funcionalidades JavaScript
```javascript
function filterRows() {
    var searchValue = $("#searchInput").val().toLowerCase();
    var fileTypeValue = $("#fileTypeFilter").val();
    $("table tbody tr").each(function() {
        var fileName = $(this).find("td:first").text().toLowerCase();
        var rowType = $(this).data("file-type");
        $(this).toggle(
            fileName.indexOf(searchValue) > -1 && 
            (fileTypeValue === "all" || rowType === fileTypeValue)
        );
    });
}
```
- Filtros dinâmicos
- Atualização em tempo real
- Interatividade

#### 3. Gestão de Estado
- Controle de sessão
- Persistência de preferências
- Feedback de operações

### Considerações de Performance

15. **Otimização de Carregamento**
   - Uso de cache
   - Carregamento lazy
   - Compressão de recursos

16. **Gestão de Memória**
   - Liberação de recursos
   - Controle de conexões
   - Limpeza de arquivos temporários

17. **Escalabilidade**
   - Modularização do código
   - Separação de responsabilidades
   - Facilidade de manutenção

### Manutenção e Monitoramento

18. **Logs**
   - Rotação diária
   - Níveis de severidade
   - Informações contextuais

19. **Backup**
   - Banco de dados SQLite
   - Arquivos de configuração
   - Credenciais salvas

20. **Monitoramento**
   - Uso de recursos
   - Erros e exceções
   - Performance do sistema

# 2 - Códigos completos

## 2.1 - Pagina Inicial

```python
import os

import urllib.parse

import pandas as pd

import streamlit as st

from datetime import datetime, date

from dateutil.relativedelta import relativedelta

from io import BytesIO

  

# ------------------------------------------------------------------------------

# Configuração da Página

# ------------------------------------------------------------------------------

st.set_page_config(

    page_title="Projetos em Execução FADEX",

    page_icon=("C:/Users/Admin/Documents/pdf-bank-converter/frontend/build/fadex.ico"),

    layout="wide"

)

st.markdown(

    """

    <style>

    /* Esconde o menu (três pontinhos) */

    #MainMenu {visibility: hidden;}

  

    /* Esconde o cabeçalho com a barrinha gradiente no topo */

    header {visibility: hidden;}

  

    /* Opcional: Esconde também o rodapé, se desejar

    footer {visibility: hidden;}

    */

    </style>

    """,

    unsafe_allow_html=True

)

# ------------------------------------------------------------------------------

# Constantes

# ------------------------------------------------------------------------------

FLASK_SERVER_URL = "http://192.168.3.234:5000"

# ------------------------------------------------------------------------------

# Funções Utilitárias

# ------------------------------------------------------------------------------

def get_mod_time(file_path):

    return os.path.getmtime(file_path)

def format_button(caminho):

    """

    Converte o caminho em um botão que abre a pasta no servidor Flask.

    """

    if pd.notnull(caminho) and caminho != "":

        encoded_path = urllib.parse.quote(caminho)

        url = f"{FLASK_SERVER_URL}/folder?path={encoded_path}"

        return (

            f'<a href="{url}" target="_blank">'

            f'<button style="background-color: #f8f9fa; color: #28a745; '

            f'border: 1px solid #28a745; border-radius: 4px; padding: 4px 8px; '

            f'font-size: 0.9em;">Link da Pasta</button></a>'

        )

    return ""
 

@st.cache_data

def load_data(file_path, mtime):

    df = pd.read_excel(file_path, sheet_name='Planilha1', header=1)

    if df.columns[0].startswith("Unnamed") or df.iloc[:, 0].isnull().all():

        df = df.iloc[:, 1:]

    return df  

@st.cache_data

def load_caminhos(file_path, mtime):

    df_cam = pd.read_excel(file_path, sheet_name='Sheet1', header=0)

    if "Nome da Pasta" in df_cam.columns:

        df_cam["Conta Corrente"] = df_cam["Nome da Pasta"].str.split(" -").str[0]

        df_cam = df_cam.drop(columns=["Nome da Pasta"])

    return df_cam

  

# ------------------------------------------------------------------------------

# Funções de Transformação dos Dados

# ------------------------------------------------------------------------------

def transform_data(df):

    if "Núm. Projeto" in df.columns:

        df["Núm. Projeto"] = pd.to_numeric(df["Núm. Projeto"], errors='coerce', downcast='integer')

    colunas_data = [

        "Data de Vigência Inicial", "Data de Vigência Final",

        "Data de Vigência Inicial Atual", "Data de Vigência Atual Final",

        "Data de Assinatura", "Data de Início de Execução", "Data de Término de Execução"

    ]

    for col in colunas_data:

        if col in df.columns:

            df[col] = pd.to_datetime(df[col], errors='coerce')

            df[col] = df[col].dt.strftime("%Y-%m-%d")

    if "Status do Projeto" in df.columns:

        df = df[df["Status do Projeto"] == "EXECUÇÃO"]

    colunas_remover = [

        "Número SAP", "UF de Execução do Projeto", "Área", "Moeda",

        "Classificação do Projeto", "Exigir Rateio com Base na Moeda Estrangeira",

        "Unidades", "Agente Financiador Secundário", "Orçamento Proposto"

    ]

    df = df.drop(columns=colunas_remover, errors='ignore')

    if "Dados Bancários" in df.columns:

        partes = df["Dados Bancários"].str.split(" - ", expand=True)

        if partes.shape[1] >= 3:

            df["Conta Corrente"] = partes[2]

        df = df.drop(columns=["Dados Bancários"], errors='ignore')

    if "Conta Corrente" in df.columns:

        df["Conta Corrente"] = df["Conta Corrente"].str.replace("CC: ", "", regex=False)

        df["Conta Corrente"] = df["Conta Corrente"].str.replace(", BANCO DO BRASIL S/A", "", regex=False)

    renomear = {

        "Assistentes": "Responsáveis do Projeto",

        "Data de Vigência Inicial Atual": "Vigência Inicial",

        "Data de Vigência Atual Final": "Vigência Final",

        "Exercício de Início de Execução": "Exercício",

        "Disponibilizar o Projeto no Portal do Coordenador": "Projetos que estão no Portal do Coordenador",

        "Município de Execução do Projeto": "Município de Execução"

    }

    df = df.rename(columns=renomear)

    colunas_adicionais = [

        "Data de Término de Execução", "Departamentos", "Instrumento Jurídico",

        "Título do Jurídico", "Título do Pré-Projeto", "Número Oficial",

        "Número do Contrato", "Objeto", "Objeto do Pré-Projeto",

        "Data de Vigência Inicial", "Data de Vigência Final", "Data de Assinatura",

        "Data de Início de Execução"

    ]

    df = df.drop(columns=colunas_adicionais, errors='ignore')

    if "Projetos que estão no Portal do Coordenador" in df.columns:

        df["Projetos que estão no Portal do Coordenador"] = df["Projetos que estão no Portal do Coordenador"].replace({

            "0": "Não", "1": "Sim"

        })

    colunas_desejadas = [

        "Conta Corrente", "Responsáveis do Projeto", "Núm. Projeto", "Título do Projeto",

        "Vigência Inicial", "Vigência Final", "Exercício",

        "Tipo\\Categoria do Projeto", "Instituições, Unidades e Centros",

        "Orçamento Aprovado"

    ]

    colunas_desejadas = [c for c in colunas_desejadas if c in df.columns]

    df = df[colunas_desejadas]

    contas_invalidas = ["11005-1", "1111-1", "11137-6", "11402-2", "13003965-0", "5970-6"]

    if "Conta Corrente" in df.columns:

        df = df[~df["Conta Corrente"].isin(contas_invalidas)]

        df = df[df["Conta Corrente"] != "12107-X"]

    return df

  

def merge_caminhos(df_projetos, df_caminhos):

    df_merged = pd.merge(df_projetos, df_caminhos, on="Conta Corrente", how="left")

    cols = list(df_merged.columns)

    if "Caminho Completo" in cols:

        cols.remove("Caminho Completo")

        nova_ordem = ["Caminho Completo"] + cols

        df_merged = df_merged[nova_ordem]

    return df_merged

  

def format_currency(value):

    try:

        return f'R$ {float(value):,.2f}'.replace(",", "X").replace(".", ",").replace("X", ".")

    except Exception:

        return value

  

def compute_status(date_str):

    """

    Retorna o status do prazo com cores de alerta (fundo vermelho para vencido e verde para prazo em aberto)

    em um elemento HTML.

    """

    if pd.isna(date_str) or str(date_str).strip() == "":

        Prazo_atual = "Vigência não cadastrada no SAGI"

    else:

        try:

            dt = datetime.strptime(date_str, "%Y-%m-%d").date()

        except Exception:

            Prazo_atual = "Data inválida"

            return f'<span style="color: red;">{Prazo_atual}</span>'

        today = date.today()

        if dt < today:

            days_diff = (today - dt).days

            if days_diff > 30:

                rd = relativedelta(today, dt)

                parts = []

                if rd.years > 0:

                    parts.append(f"{rd.years} " + ("ano" if rd.years == 1 else "anos"))

                if rd.months > 0:

                    parts.append(f"{rd.months} " + ("mês" if rd.months == 1 else "meses"))

                if rd.days > 0:

                    parts.append(f"{rd.days} " + ("dia" if rd.days == 1 else "dias"))

                breakdown = " e ".join(parts) if len(parts) <= 2 else ", ".join(parts[:-1]) + " e " + parts[-1]

                Prazo_atual = "Vencido há " + breakdown

            else:

                Prazo_atual = "Vencido há " + str(days_diff) + (" dia" if days_diff == 1 else " dias")

        else:

            days_diff = (dt - today).days

            if days_diff > 30:

                rd = relativedelta(dt, today)

                parts = []

                if rd.years > 0:

                    parts.append(f"{rd.years} " + ("ano" if rd.years == 1 else "anos"))

                if rd.months > 0:

                    parts.append(f"{rd.months} " + ("mês" if rd.months == 1 else "meses"))

                if rd.days > 0:

                    parts.append(f"{rd.days} " + ("dia" if rd.days == 1 else "dias"))

                breakdown = " e ".join(parts) if len(parts) <= 2 else ", ".join(parts[:-1]) + " e " + parts[-1]

                Prazo_atual = "Faltam " + breakdown

            else:

                Prazo_atual = "Faltam " + str(days_diff) + (" dia" if days_diff == 1 else " dias")

    style = ""

    if "NÃO CADASTRADA" in Prazo_atual.upper():

        style = "color: red;"

    elif "Vencido" in Prazo_atual:

        style = "background-color: #f8d7da; color: #721c24; padding: 5px; border-radius: 4px;"

    elif "Faltam" in Prazo_atual:

        style = "background-color: #d4edda; color: #155724; padding: 5px; border-radius: 4px;"

    return f'<span style="{style}">{Prazo_atual}</span>'

  

def to_excel(df):

    """

    Exporta o DataFrame para Excel.

    """

    output = BytesIO()

    with pd.ExcelWriter(output, engine="xlsxwriter") as writer:

        df.to_excel(writer, index=False, sheet_name="Projetos")

        workbook = writer.book

        worksheet = writer.sheets["Projetos"]

        n_rows, n_cols = df.shape

        for i, col in enumerate(df.columns):

            max_len = max(df[col].astype(str).map(len).max(), len(col)) + 2

            worksheet.set_column(i, i, max_len)

        worksheet.add_table(0, 0, n_rows, n_cols - 1, {

            "columns": [{"header": col} for col in df.columns],

            "style": "TableStyleMedium1",

            "autofilter": True,

        })

    return output.getvalue()

  

# ------------------------------------------------------------------------------

# Carregamento e Preparação dos Dados

# ------------------------------------------------------------------------------

caminho_excel = r'\\192.168.3.68\Fluxos - automação\02 - DADOS DA PLANILHA DAS DUPLAS\1 - PROJETOS SAGI.xlsx'

caminho_caminhos = r'\\192.168.3.68\Fluxos - automação\02 - DADOS DA PLANILHA DAS DUPLAS\3 - CAMINHOS.xlsx'

  

mtime_excel = get_mod_time(caminho_excel)

mtime_caminhos = get_mod_time(caminho_caminhos)

  

df_raw = load_data(caminho_excel, mtime_excel)

df_caminhos = load_caminhos(caminho_caminhos, mtime_caminhos)

  

df_formatado = transform_data(df_raw)

df_final = merge_caminhos(df_formatado, df_caminhos)

df_base = df_final.copy()

  

# ------------------------------------------------------------------------------

# Filtros na Sidebar

# ------------------------------------------------------------------------------

st.sidebar.header("Filtros")

  

if st.sidebar.button("Limpar filtros"):

    keys_to_clear = [

        "orcamento_range", "titulo_filtro", "vigencia_filter",

        "selected_conta", "selected_dupla", "vencidos_checkbox",

        "enable_date_filter", "date_filter_column", "date_range_filter"

    ]

    for key in keys_to_clear:

        if key in st.session_state:

            del st.session_state[key]

  

if "Orçamento Aprovado" in df_final.columns:

    orcamento_col = df_final["Orçamento Aprovado"]

    min_orcamento = float(orcamento_col.min())

    max_orcamento = float(orcamento_col.max())

    default_range = st.session_state.get("orcamento_range", (min_orcamento, max_orcamento))

    intervalo_selecionado = st.sidebar.slider(

        "Orçamento Aprovado",

        min_value=min_orcamento,

        max_value=max_orcamento,

        value=default_range,

        step=0.01,

        key="orcamento_range"

    )

    df_final = df_final[(orcamento_col >= intervalo_selecionado[0]) & (orcamento_col <= intervalo_selecionado[1])]

  

titulo_filtro = st.sidebar.text_input(

    "Filtrar por Título do Projeto",

    st.session_state.get("titulo_filtro", ""),

    key="titulo_filtro"

)

if "Título do Projeto" in df_final.columns and titulo_filtro:

    df_final = df_final[df_final["Título do Projeto"].str.contains(titulo_filtro, case=False, na=False)]

  

vigencia_filter = st.sidebar.selectbox(

    "Filtrar por Vigência Final",

    options=["Todos", "Vencer neste mês", "Vencer em 2 meses", "Vencer em 3 meses"],

    index=0 if st.session_state.get("vigencia_filter", "Todos") == "Todos" else 1,

    key="vigencia_filter"

)

if "Vigência Final" in df_final.columns:

    df_final["Vigência Final_dt"] = pd.to_datetime(df_final["Vigência Final"], format="%Y-%m-%d", errors='coerce')

    today = pd.Timestamp(date.today())

    if vigencia_filter == "Vencer neste mês":

         start_date = today.replace(day=1)

         end_date = today + pd.offsets.MonthEnd(0)

         df_final = df_final[(df_final["Vigência Final_dt"] >= start_date) & (df_final["Vigência Final_dt"] <= end_date)]

    elif vigencia_filter == "Vencer em 2 meses":

         target_date = today + relativedelta(months=2)

         start_date = target_date.replace(day=1)

         end_date = target_date + pd.offsets.MonthEnd(0)

         df_final = df_final[(df_final["Vigência Final_dt"] >= start_date) & (df_final["Vigência Final_dt"] <= end_date)]

    elif vigencia_filter == "Vencer em 3 meses":

         target_date = today + relativedelta(months=3)

         start_date = target_date.replace(day=1)

         end_date = target_date + pd.offsets.MonthEnd(0)

         df_final = df_final[(df_final["Vigência Final_dt"] >= start_date) & (df_final["Vigência Final_dt"] <= end_date)]

    df_final.drop(columns=["Vigência Final_dt"], inplace=True)

  

conta_options = sorted(df_final["Conta Corrente"].dropna().unique())

selected_conta = st.sidebar.multiselect(

    "Filtrar por Conta Corrente",

    options=conta_options,

    default=st.session_state.get("selected_conta", []),

    key="selected_conta"

)

if selected_conta:

    df_final = df_final[df_final["Conta Corrente"].isin(selected_conta)]

  

dupla_options = sorted(df_final["Responsáveis do Projeto"].dropna().unique())

selected_dupla = st.sidebar.multiselect(

    "Filtrar por Responsável",

    options=dupla_options,

    default=st.session_state.get("selected_dupla", []),

    key="selected_dupla"

)

if selected_dupla:

    df_final = df_final[df_final["Responsáveis do Projeto"].isin(selected_dupla)]

  

vencidos_checkbox = st.sidebar.checkbox(

    "Mostrar apenas projetos vencidos",

    value=st.session_state.get("vencidos_checkbox", False),

    key="vencidos_checkbox"

)

if vencidos_checkbox and "Vigência Final" in df_final.columns:

    df_final["Vigência Final_dt"] = pd.to_datetime(df_final["Vigência Final"], format="%Y-%m-%d", errors='coerce')

    df_final = df_final[df_final["Vigência Final_dt"] < pd.Timestamp(date.today())]

    df_final.drop(columns=["Vigência Final_dt"], inplace=True)

  

enable_date_filter = st.sidebar.checkbox(

    "Filtrar por intervalo de data",

    value=st.session_state.get("enable_date_filter", False),

    key="enable_date_filter"

)

if enable_date_filter:

    date_filter_column = st.sidebar.selectbox(

        "Filtrar por coluna de data",

        options=["Vigência Inicial", "Vigência Final"],

        index=0,

        key="date_filter_column"

    )

    if date_filter_column == "Vigência Inicial":

        default_range = (

            min(pd.to_datetime(df_base["Vigência Inicial"], format="%Y-%m-%d", errors='coerce').dropna()).date(),

            max(pd.to_datetime(df_base["Vigência Inicial"], format="%Y-%m-%d", errors='coerce').dropna()).date()

        )

    else:

        default_range = (

            min(pd.to_datetime(df_base["Vigência Final"], format="%Y-%m-%d", errors='coerce').dropna()).date(),

            max(pd.to_datetime(df_base["Vigência Final"], format="%Y-%m-%d", errors='coerce').dropna()).date()

        )

    date_range = st.sidebar.date_input(

        "Selecione o intervalo de datas",

        value=st.session_state.get("date_range_filter", default_range),

        key="date_range_filter"

    )

    try:

        df_final[date_filter_column + "_dt"] = pd.to_datetime(df_final[date_filter_column], format="%Y-%m-%d", errors='coerce')

        if isinstance(date_range, (list, tuple)):

            start_date, end_date = date_range

        else:

            start_date = end_date = date_range

        df_final = df_final[

            (df_final[date_filter_column + "_dt"] >= pd.Timestamp(start_date)) &

            (df_final[date_filter_column + "_dt"] <= pd.Timestamp(end_date))

        ]

        df_final.drop(columns=[date_filter_column + "_dt"], inplace=True)

    except Exception:

        st.sidebar.error("Erro ao aplicar filtro de data. Verifique os valores informados.")

  

if "Caminho Completo" in df_final.columns:

    df_final["Caminho Completo"] = df_final["Caminho Completo"].apply(format_button)

    df_final = df_final.rename(columns={"Caminho Completo": "Link da Pasta"})

  

if "Orçamento Aprovado" in df_final.columns:

    df_final["Orçamento Aprovado"] = df_final["Orçamento Aprovado"].apply(format_currency)

  

if "Vigência Final" in df_final.columns:

    df_final["Prazo_atual"] = df_final["Vigência Final"].apply(compute_status)

else:

    df_final["Prazo_atual"] = ""

  

cols = list(df_final.columns)

for col in ["Conta Corrente", "Link da Pasta", "Prazo_atual"]:

    if col in cols:

        cols.remove(col)

nova_ordem = ["Conta Corrente", "Link da Pasta", "Prazo_atual"] + cols

df_final = df_final[nova_ordem]

  

if "Núm. Projeto" in df_final.columns:

    df_final = df_final.drop_duplicates(subset=["Núm. Projeto"])

  

# ------------------------------------------------------------------------------

# Exibição dos Dados na Página

# ------------------------------------------------------------------------------

st.title("Projetos em Execução FADEX")

st.markdown('<hr style="border: 3px solid #32CD32; border-radius: 10px;">', unsafe_allow_html=True)

  

# --- Botão de Download (estilizado em verde) ---

st.markdown(

    """

    <style>

    .stDownloadButton button {

        background-color: #28a745 !important;

        color: white !important;

        border: none !important;

    }

    </style>

    """,

    unsafe_allow_html=True,

)

# Para o download do Excel, removemos as colunas "Prazo_atual" e "Link da Pasta"

df_excel = df_final.copy()

df_excel = df_excel.drop(columns=["Prazo_atual", "Link da Pasta"], errors='ignore')

excel_data = to_excel(df_excel)

st.download_button(

    label="Download dos dados filtrados",

    data=excel_data,

    file_name="projetos_filtrados.xlsx",

    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"

)

  

# --- Exibição da Tabela com Scroll Superior e Colunas Redimensionáveis ---

html_table = df_final.to_html(escape=False, index=False)

html_code = f"""

<style>

    table {{

        border-collapse: collapse;

        width: 100%;

    }}

    table thead th {{

        position: sticky;

        top: 0;

        z-index: 2;

    }}

    table tr th, table tr td {{

        white-space: nowrap;

        overflow: hidden;

        text-overflow: ellipsis;

        padding: 12px !important;

        font-size: 14px;

        width: 200px;

        position: relative;

    }}

    table tr th {{

        text-align: left;  /* Cabeçalho alinhado à esquerda */

        vertical-align: middle;

        background-color: #e0e0e0;

        font-weight: bold;

    }}

    @media (prefers-color-scheme: dark) {{

        table tr th {{

            background-color: #444444 !important;

            color: #ffffff !important;

        }}

    }}

    .table-container {{

        overflow: auto;

        max-height: 500px;

        scrollbar-width: thin;

    }}

    .top-scroll {{

        overflow-x: scroll;

        overflow-y: hidden;

        height: 20px;

        border-bottom: 2px solid #ccc;

    }}

    .top-scroll > div {{

        height: 1px;

    }}

    .resizer {{

        position: absolute;

        right: 0;

        top: 0;

        width: 5px;

        height: 100%;

        cursor: col-resize;

        user-select: none;

    }}

</style>

  

<div class="top-scroll" id="top-scroll">

  <div id="top-scroll-content"></div>

</div>

<div class="table-container" id="table-container">

  {html_table}

</div>

  

<script>

  // Sincroniza o scroll horizontal do topo com o container da tabela

  function syncScrollWidth() {{

      const table = document.querySelector('#table-container table');

      if(table) {{

          const tableWidth = table.scrollWidth;

          document.getElementById('top-scroll-content').style.width = tableWidth + 'px';

      }}

  }}

  syncScrollWidth();

  window.addEventListener('resize', syncScrollWidth);

  const topScroll = document.getElementById('top-scroll');

  const tableContainer = document.getElementById('table-container');

  topScroll.addEventListener('scroll', function() {{

      tableContainer.scrollLeft = topScroll.scrollLeft;

  }});

  tableContainer.addEventListener('scroll', function() {{

      topScroll.scrollLeft = tableContainer.scrollLeft;

  }});

  // Função para tornar as colunas redimensionáveis

  function makeColumnsResizable(table) {{

      const thElements = table.querySelectorAll("th");

      thElements.forEach((th) => {{

          if (!th.querySelector('.resizer')) {{

              const resizer = document.createElement("div");

              resizer.classList.add("resizer");

              th.appendChild(resizer);

              let startX, startWidth;

              resizer.addEventListener("mousedown", function(e) {{

                  startX = e.clientX;

                  startWidth = th.offsetWidth;

                  document.addEventListener("mousemove", mouseMoveHandler);

                  document.addEventListener("mouseup", mouseUpHandler);

              }});

              function mouseMoveHandler(e) {{

                  const newWidth = startWidth + (e.clientX - startX);

                  th.style.width = newWidth + "px";

                  const index = Array.from(th.parentNode.children).indexOf(th);

                  table.querySelectorAll("tr").forEach(row => {{

                      if(row.children[index]) {{

                          row.children[index].style.width = newWidth + "px";

                      }}

                  }});

              }}

              function mouseUpHandler() {{

                  document.removeEventListener("mousemove", mouseMoveHandler);

                  document.removeEventListener("mouseup", mouseUpHandler);

              }}

          }}

      }});

  }}

  document.addEventListener("DOMContentLoaded", function() {{

      const table = document.querySelector("#table-container table");

      if(table) {{

          makeColumnsResizable(table);

      }}

  }});

</script>

"""

st.markdown(html_code, unsafe_allow_html=True)
```

## 2.2 - Pagina de Vigências

```python

import os

import sqlite3

import pandas as pd

import streamlit as st

from datetime import datetime, date

from dateutil.relativedelta import relativedelta

from io import BytesIO

import urllib.parse

  

# -----------------------------------------------------------------------------

# Configuração da Página

# -----------------------------------------------------------------------------

st.set_page_config(

    page_title="Monitoramento de Vigências FADEX",

    page_icon=("C:/Users/Admin/Documents/pdf-bank-converter/frontend/build/fadex.ico"),

    layout="wide"

)

  

st.markdown(

    """

    <style>

    /* Esconde o menu (três pontinhos) */

    #MainMenu {visibility: hidden;}

  

    /* Esconde o cabeçalho com a barrinha gradiente no topo */

    header {visibility: hidden;}

  

    /* Opcional: Esconde também o rodapé, se desejar

    footer {visibility: hidden;}

    */

    </style>

    """,

    unsafe_allow_html=True

)

  

# -----------------------------------------------------------------------------

# Definição dos Caminhos dos Arquivos

# -----------------------------------------------------------------------------

caminho_excel = r'\\192.168.3.68\Fluxos - automação\02 - DADOS DA PLANILHA DAS DUPLAS\1 - PROJETOS SAGI.xlsx'

caminho_caminhos = r'\\192.168.3.68\Fluxos - automação\02 - DADOS DA PLANILHA DAS DUPLAS\3 - CAMINHOS.xlsx'

  

# -----------------------------------------------------------------------------

# Função para Obter o Tempo de Modificação dos Arquivos

# -----------------------------------------------------------------------------

def get_mod_time(file_path):

    return os.path.getmtime(file_path)

  

# -----------------------------------------------------------------------------

# Funções de Carregamento dos Dados com Cache

# -----------------------------------------------------------------------------

@st.cache_data

def load_data(file_path, mtime):

    df = pd.read_excel(file_path, sheet_name='Planilha1', header=1)

    if df.columns[0].startswith("Unnamed") or df.iloc[:, 0].isnull().all():

        df = df.iloc[:, 1:]

    return df

  

@st.cache_data

def load_caminhos(file_path, mtime):

    df_cam = pd.read_excel(file_path, sheet_name='Sheet1', header=0)

    if "Nome da Pasta" in df_cam.columns:

        df_cam["Conta Corrente"] = df_cam["Nome da Pasta"].str.split(" -").str[0]

        df_cam = df_cam.drop(columns=["Nome da Pasta"])

    return df_cam

  

mtime_excel = get_mod_time(caminho_excel)

mtime_caminhos = get_mod_time(caminho_caminhos)

  

df_raw = load_data(caminho_excel, mtime_excel)

df_caminhos = load_caminhos(caminho_caminhos, mtime_caminhos)

  

# -----------------------------------------------------------------------------

# Função para Transformação dos Dados

# -----------------------------------------------------------------------------

def transform_data(df):

    if "Núm. Projeto" in df.columns:

        df["Núm. Projeto"] = pd.to_numeric(df["Núm. Projeto"], errors="coerce", downcast="integer")

    colunas_data = [

        "Data de Vigência Inicial", "Data de Vigência Final",

        "Data de Vigência Inicial Atual", "Data de Vigência Atual Final",

        "Data de Assinatura", "Data de Início de Execução", "Data de Término de Execução"

    ]

    for col in colunas_data:

        if col in df.columns:

            df[col] = pd.to_datetime(df[col], errors="coerce")

            # Inicialmente, as datas ficam no formato YYYY-MM-DD

            df[col] = df[col].dt.strftime("%Y-%m-%d")

    if "Status do Projeto" in df.columns:

        df = df[df["Status do Projeto"] == "EXECUÇÃO"]

    colunas_remover = [

        "Número SAP", "UF de Execução do Projeto", "Área", "Moeda",

        "Classificação do Projeto", "Exigir Rateio com Base na Moeda Estrangeira",

        "Unidades", "Agente Financiador Secundário", "Orçamento Proposto"

    ]

    df = df.drop(columns=colunas_remover, errors="ignore")

    if "Dados Bancários" in df.columns:

        partes = df["Dados Bancários"].str.split(" - ", expand=True)

        if partes.shape[1] >= 3:

            df["Conta Corrente"] = partes[2]

        df = df.drop(columns=["Dados Bancários"], errors="ignore")

    if "Conta Corrente" in df.columns:

        df["Conta Corrente"] = df["Conta Corrente"].str.replace("CC: ", "", regex=False)

        df["Conta Corrente"] = df["Conta Corrente"].str.replace(", BANCO DO BRASIL S/A", "", regex=False)

    renomear = {

        "Assistentes": "Responsáveis do Projeto",

        "Data de Vigência Inicial Atual": "Vigência Inicial",

        "Data de Vigência Atual Final": "Vigência Final",

        "Exercício de Início de Execução": "Exercício",

        "Disponibilizar o Projeto no Portal do Coordenador": "Projetos que estão no Portal do Coordenador",

        "Município de Execução do Projeto": "Município de Execução"

    }

    df = df.rename(columns=renomear)

    colunas_adicionais = [

        "Data de Término de Execução", "Departamentos", "Instrumento Jurídico",

        "Título do Jurídico", "Título do Pré-Projeto", "Número Oficial",

        "Número do Contrato", "Objeto", "Objeto do Pré-Projeto",

        "Data de Vigência Inicial", "Data de Vigência Final", "Data de Assinatura",

        "Data de Início de Execução"

    ]

    df = df.drop(columns=colunas_adicionais, errors="ignore")

    if "Projetos que estão no Portal do Coordenador" in df.columns:

        df["Projetos que estão no Portal do Coordenador"] = df["Projetos que estão no Portal do Coordenador"].replace({

            "0": "Não", "1": "Sim"

        })

    colunas_desejadas = [

        "Conta Corrente", "Responsáveis do Projeto", "Núm. Projeto", "Título do Projeto",

        "Vigência Inicial", "Vigência Final", "Exercício",

        "Tipo\\Categoria do Projeto", "Instituições, Unidades e Centros",

        "Orçamento Aprovado"

    ]

    colunas_desejadas = [c for c in colunas_desejadas if c in df.columns]

    df = df[colunas_desejadas]

    contas_invalidas = ["11005-1", "1111-1", "11137-6", "11402-2", "13003965-0", "5970-6"]

    if "Conta Corrente" in df.columns:

        df = df[~df["Conta Corrente"].isin(contas_invalidas)]

        df = df[df["Conta Corrente"] != "12107-X"]

    return df

  

# -----------------------------------------------------------------------------

# Função para Mesclar os Dados de Caminhos

# -----------------------------------------------------------------------------

def merge_caminhos(df_projetos, df_caminhos):

    df_merged = pd.merge(df_projetos, df_caminhos, on="Conta Corrente", how="left")

    df_merged = df_merged.drop(columns=["Caminho Completo"], errors="ignore")

    return df_merged

  

df_formatado = transform_data(df_raw)

df_final = merge_caminhos(df_formatado, df_caminhos)

  

# -----------------------------------------------------------------------------

# Sistema de Categorização de Vigências

# -----------------------------------------------------------------------------

def categorize_deadline(vigencia_final):

    try:

        dt = datetime.strptime(vigencia_final, "%Y-%m-%d").date()

    except Exception:

        return "Data Inválida"

    today = date.today()

    diff = (dt - today).days

    if dt < today:

        return "PROBLEMA"

    elif diff <= 30:

        return "CRÍTICO"

    elif diff <= 60:

        return "ATENÇÃO"

    elif diff <= 90:

        return "MONITORAMENTO"

    else:

        return "REGULAR"

  

if "Vigência Final" in df_final.columns:

    df_final["Categoria"] = df_final["Vigência Final"].apply(categorize_deadline)

else:

    df_final["Categoria"] = "N/A"

  

# Remoção de pontuação da coluna "Núm. Projeto"

if "Núm. Projeto" in df_final.columns:

    df_final["Núm. Projeto"] = df_final["Núm. Projeto"].astype(str).str.replace(r'\D', '', regex=True)

  

# Remoção da coluna "Exercício"

df_final = df_final.drop(columns=["Exercício"], errors="ignore")

  

# -----------------------------------------------------------------------------

# Função para Formatar Valores como Moeda (R$)

# -----------------------------------------------------------------------------

def format_currency(value):

    try:

        return f'R$ {float(value):,.2f}'.replace(",", "X").replace(".", ",").replace("X", ".")

    except Exception:

        return value

  

# -----------------------------------------------------------------------------

# Banco de Dados SQLite – Status, Observações e Data do Aditivo

# -----------------------------------------------------------------------------

conn = sqlite3.connect("project_status.db", check_same_thread=False)

cursor = conn.cursor()

cursor.execute('''

    CREATE TABLE IF NOT EXISTS project_status (

        Conta_Corrente TEXT PRIMARY KEY,

        status TEXT,

        observation TEXT,

        data_aditivo TEXT,

        updated_at TEXT,

        updated_by TEXT

    )

''')

conn.commit()

  

def load_project_status(conta_corrente):

    cursor.execute(

        "SELECT status, observation, data_aditivo, updated_at, updated_by FROM project_status WHERE Conta_Corrente=?",

        (conta_corrente,)

    )

    result = cursor.fetchone()

    if result:

        return {

            "status": result[0],

            "observation": result[1],

            "data_aditivo": result[2],

            "updated_at": result[3],

            "updated_by": result[4]

        }

    else:

        return {"status": "", "observation": "", "data_aditivo": "", "updated_at": "", "updated_by": ""}

  

def update_project_status(conta_corrente, status_value, observation, updated_by, data_aditivo=None):

    updated_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    data_aditivo_str = data_aditivo.strftime("%Y-%m-%d") if data_aditivo is not None else ""

    cursor.execute('''

         INSERT INTO project_status (Conta_Corrente, status, observation, data_aditivo, updated_at, updated_by)

         VALUES (?, ?, ?, ?, ?, ?)

         ON CONFLICT(Conta_Corrente) DO UPDATE SET

              status=excluded.status,

              observation=excluded.observation,

              data_aditivo=excluded.data_aditivo,

              updated_at=excluded.updated_at,

              updated_by=excluded.updated_by

    ''', (conta_corrente, status_value, observation, data_aditivo_str, updated_at, updated_by))

    conn.commit()

    return updated_at

  

# -----------------------------------------------------------------------------

# Sidebar – Filtros

# Ordem: 1) Dupla do Projeto, 2) Categoria de Urgência, 3) Status Definido, 4) Conta Corrente

# -----------------------------------------------------------------------------

st.sidebar.header("Filtros")

  

# Filter 1: Dupla do Projeto

dupla_options = sorted(df_final["Responsáveis do Projeto"].dropna().unique())

selected_dupla = st.sidebar.multiselect("Filtrar por Dupla do Projeto", options=dupla_options)

if selected_dupla:

    df_filtered = df_final[df_final["Responsáveis do Projeto"].isin(selected_dupla)]

    # Se houver filtro por dupla, não exibe projetos com categoria "REGULAR"

    df_filtered = df_filtered[df_filtered["Categoria"] != "REGULAR"]

else:

    df_filtered = df_final.copy()

  

# Filter 2: Categoria de Urgência (dinâmica)

if not df_filtered.empty:

    available_urgency = sorted(df_filtered["Categoria"].dropna().unique())

    available_urgency = ["Todos"] + available_urgency

else:

    available_urgency = ["Todos"]

selected_urgency = st.sidebar.selectbox("Categoria de Urgência", available_urgency)

if selected_urgency != "Todos":

    df_filtered = df_filtered[df_filtered["Categoria"] == selected_urgency]

  

# Filter 3: Status Definido

status_filter_options = ["Todos", "Definido", "Não Definido"]

selected_status = st.sidebar.selectbox("Filtrar por Status Definido", status_filter_options)

def add_status_defined_column(df):

    status_list = []

    for conta in df["Conta Corrente"]:

        info = load_project_status(conta)

        if info["status"].strip():

            status_list.append("Definido")

        else:

            status_list.append("Não Definido")

    df["Status Definido"] = status_list

    return df

df_filtered = add_status_defined_column(df_filtered)

if selected_status != "Todos":

    df_filtered = df_filtered[df_filtered["Status Definido"] == selected_status]

  

# Filter 4: Conta Corrente (dinâmica)

if not df_filtered.empty:

    available_conta = sorted(df_filtered["Conta Corrente"].dropna().unique())

else:

    available_conta = []

selected_conta_filter = st.sidebar.multiselect("Filtrar por Conta Corrente", options=available_conta)

if selected_conta_filter:

    df_filtered = df_filtered[df_filtered["Conta Corrente"].isin(selected_conta_filter)]

  

# Aplica máscara de moeda em "Orçamento Aprovado"

if "Orçamento Aprovado" in df_filtered.columns:

    df_filtered["Orçamento Aprovado"] = df_filtered["Orçamento Aprovado"].apply(format_currency)

  

# Converte as datas para o formato DD-MM-YYYY

date_cols = ["Vigência Inicial", "Vigência Final"]

for col in date_cols:

    if col in df_filtered.columns:

        df_filtered[col] = pd.to_datetime(df_filtered[col], format="%Y-%m-%d", errors="coerce").dt.strftime("%d-%m-%Y")

  

# Remove duplicidade na coluna "Núm. Projeto" para exibir valores únicos

if "Núm. Projeto" in df_filtered.columns:

    df_filtered = df_filtered.drop_duplicates(subset=["Núm. Projeto"])

  

# Adiciona ícones à coluna "Título do Projeto" com base na "Categoria"

def add_icon_to_title(row):

    cat = row["Categoria"]

    title = row["Título do Projeto"]

    icon = ""

    if cat == "PROBLEMA":

        icon = "🔴"

    elif cat == "CRÍTICO":

        icon = "🟠"

    elif cat == "ATENÇÃO":

        icon = "🟡"

    elif cat == "MONITORAMENTO":

        icon = "🔵"

    elif cat == "REGULAR":

        icon = "🟢"

    return f"{icon} {title}"

if "Título do Projeto" in df_filtered.columns:

    df_filtered["Título do Projeto"] = df_filtered.apply(add_icon_to_title, axis=1)

  

# Reordena as colunas para que "Categoria" seja a primeira

if "Categoria" in df_filtered.columns:

    cols = df_filtered.columns.tolist()

    cols.remove("Categoria")

    df_filtered = df_filtered[["Categoria"] + cols]

  

# -----------------------------------------------------------------------------

# Legenda das Categorias de Vigência

# -----------------------------------------------------------------------------

st.markdown("### Legenda das Categorias de Vigência")

st.markdown("""

- 🔴 **PROBLEMA - (Projeto Vencido)**

- 🟠 **CRÍTICO - (Até 30 dias para vencer)**

- 🟡 **ATENÇÃO - (31 a 60 dias para vencer)**

- 🔵 **MONITORAMENTO - (61 a 90 dias para vencer)**

- 🟢 **REGULAR - (Mais de 90 dias para vencer)**

""")

  

# -----------------------------------------------------------------------------

# Exibição da Tabela de Projetos

# -----------------------------------------------------------------------------

st.title("Projetos FADEX")

st.dataframe(df_filtered.reset_index(drop=True))

  

# -----------------------------------------------------------------------------

# Gestão de Status e Observações

# -----------------------------------------------------------------------------

st.subheader("Gestão de Status e Observações")

contas = df_filtered["Conta Corrente"].dropna().unique()

contas = sorted(contas)

contas_options = ["Selecione o Projeto"] + list(contas)

selected_conta = st.selectbox("Selecione o Projeto (Conta Corrente)", options=contas_options)

if selected_conta == "Selecione o Projeto":

    selected_conta = None

  

if selected_conta:

    project_info = load_project_status(selected_conta)

    categoria_proj = df_filtered.loc[df_filtered["Conta Corrente"] == selected_conta, "Categoria"].iloc[0]

    st.markdown(f"**Projeto:** {selected_conta}")

    st.markdown(f"**Categoria de Vigência:** {categoria_proj}")

    status_options = ["Projeto Aditivado", "Projeto não aditivado", "Indefinido"]

    current_status = project_info["status"] if project_info["status"] in status_options else "Indefinido"

    new_status = st.selectbox("Status Atual", options=status_options, index=status_options.index(current_status), key="status_select")

    if new_status == "Projeto Aditivado":

        aditivo_date = st.date_input("Data do Aditivo", value=date.today(), key="aditivo_date")

    else:

        aditivo_date = None

  

    with st.form("update_status_form"):

        new_observation = st.text_area("Observações", value=project_info["observation"])

        usuario_responsavel = df_final.loc[df_final["Conta Corrente"] == selected_conta, "Responsáveis do Projeto"].iloc[0]

        st.text_input("Usuário Responsável", value=usuario_responsavel, disabled=True)

        submit_button = st.form_submit_button("Atualizar Status")

    if submit_button:

        if new_status == "Projeto Aditivado":

            contrato_final_str = df_filtered.loc[df_filtered["Conta Corrente"] == selected_conta, "Vigência Final"].iloc[0]

            contrato_final = datetime.strptime(contrato_final_str, "%d-%m-%Y").date()

            if aditivo_date < contrato_final:

                st.error(f"A data do aditivo ({aditivo_date}) não pode ser anterior à data final do contrato ({contrato_final}).")

            else:

                st.session_state.await_confirmation = True

        else:

            st.session_state.await_confirmation = True

  

    if st.session_state.get("await_confirmation", False):

        with st.container():

            st.warning("Tem certeza que deseja atualizar o status?")

            col1, col2 = st.columns(2)

            if col1.button("Sim", key="confirm_sim"):

                updated_at = update_project_status(

                    selected_conta, new_status, new_observation,

                    usuario_responsavel, data_aditivo=aditivo_date

                )

                st.success("Status atualizado com sucesso!")

                st.info(f"Atualizado em: {updated_at}")

                st.session_state.await_confirmation = False

            if col2.button("Não", key="confirm_nao"):

                st.info("Atualização cancelada.")

                st.session_state.await_confirmation = False

  

# -----------------------------------------------------------------------------

# Opção para Visualizar as Informações Definidas dos Projetos

# -----------------------------------------------------------------------------

st.sidebar.markdown("### Visualizar Informações Definidas")

if st.sidebar.checkbox("Mostrar Informações Definidas dos Projetos"):

    df_status = pd.read_sql_query("SELECT * FROM project_status", conn)

    st.subheader("Informações Definidas dos Projetos")

    st.dataframe(df_status)

  

# -----------------------------------------------------------------------------

# Exportação dos Dados Filtrados para Excel com Formatação de Tabela (TableStyleMedium7)

# -----------------------------------------------------------------------------

def to_excel(df):

    output = BytesIO()

    with pd.ExcelWriter(output, engine="xlsxwriter") as writer:

        df.to_excel(writer, index=False, sheet_name="Projetos")

        workbook = writer.book

        worksheet = writer.sheets["Projetos"]

        n_rows, n_cols = df.shape

        # Ajuste automático das larguras das colunas

        for i, col in enumerate(df.columns):

            max_len = max(

                df[col].astype(str).map(len).max(),

                len(col)

            ) + 2

            worksheet.set_column(i, i, max_len)

        # Adiciona uma tabela formatada com o estilo "TableStyleMedium7"

        worksheet.add_table(0, 0, n_rows, n_cols - 1, {

            "columns": [{"header": col} for col in df.columns],

            "style": "TableStyleMedium1",

            "autofilter": True,

        })

    processed_data = output.getvalue()

    return processed_data

  

excel_data = to_excel(df_filtered)

st.download_button(

    label="Download dos dados filtrados",

    data=excel_data,

    file_name="projetos_filtrados.xlsx",

    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"

)

  

# -----------------------------------------------------------------------------

# Opcional: Fechar a conexão com o banco, se necessário

# -----------------------------------------------------------------------------

# conn.close()

```

## 2.3 - Dashboard

## 2.4 - Gerenciador de Arquivos

```python
import os

import urllib.parse

import datetime

import socket

import json

import io

import zipfile

  

from flask import Flask, request, render_template_string, send_file, url_for, redirect, flash, session, Response

from werkzeug.utils import secure_filename

  

# Import para autenticação no Windows

import win32wnet

import win32netcon

import pywintypes

  

# Import para criptografia

from cryptography.fernet import Fernet

  

# Import para logging

import logging

from logging.handlers import TimedRotatingFileHandler

  

# ---------------- CONFIGURAÇÕES GERAIS ----------------

app = Flask(__name__)

app.secret_key = 'algumsegredoparaasessoes'  # Use algo seguro em produção

  

# Caminhos fixos (ajuste conforme necessário)

BASE_DIR = r'\\192.168.3.68\Contratos Digitalizados'

LOG_DIR = r'C:\Users\Admin\Documents\contratos_digitalizados\logs'

CRED_FILE = r'C:\Users\Admin\Documents\contratos_digitalizados\saved_credentials.dat'

KEY_FILE = r'C:\Users\Admin\Documents\contratos_digitalizados\key.key'

ALLOWED_EXTENSIONS = set(['txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif', 'docx', 'xlsx', 'pptx'])

  

# Cria diretórios se não existirem

os.makedirs(LOG_DIR, exist_ok=True)

  

# ---------------- CONFIGURAÇÃO DO LOGGER ----------------

logger = logging.getLogger("contratos_digitalizados")

logger.setLevel(logging.DEBUG)

log_formatter = logging.Formatter(

    '%(asctime)s | IP: %(client_ip)s | Host: %(hostname)s | %(levelname)s | %(message)s'

)

log_handler = TimedRotatingFileHandler(

    os.path.join(LOG_DIR, "app.log"),

    when="midnight",

    interval=1,

    delay=True  # Atraso na abertura do arquivo para evitar bloqueios

)

log_handler.suffix = "%Y-%m-%d"

log_handler.setFormatter(log_formatter)

logger.addHandler(log_handler)

  

def log_action(level, message):

    extra = {

        "client_ip": request.remote_addr,

        "hostname": socket.gethostname()

    }

    level = level.lower()

    if level == "info":

        logger.info(message, extra=extra)

    elif level == "debug":

        logger.debug(message, extra=extra)

    elif level == "warning":

        logger.warning(message, extra=extra)

    elif level == "error":

        logger.error(message, extra=extra)

    elif level == "critical":

        logger.critical(message, extra=extra)

  

# ---------------- FUNÇÕES AUXILIARES ----------------

  

def is_allowed_path(target_path):

    """Verifica se o caminho solicitado está dentro do BASE_DIR."""

    normalized_base = os.path.abspath(BASE_DIR)

    normalized_target = os.path.abspath(target_path)

    return normalized_target.startswith(normalized_base)

  

def allowed_file(filename):

    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

  

def human_readable_size(size, decimal_places=2):

    """Converte tamanho em bytes para um formato legível."""

    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:

        if size < 1024:

            return f"{size:.{decimal_places}f} {unit}"

        size /= 1024

  

def verifica_acesso_rede(share, username, password, domain=''):

    """

    Tenta conectar ao compartilhamento usando as credenciais fornecidas.

    Retorna True se a conexão funcionar.

    """

    user = f"{domain}\\{username}" if domain else username

    net_resource = (win32netcon.RESOURCETYPE_DISK, None, share, None)  # NETRESOURCE tuple

    try:

        win32wnet.WNetAddConnection2(net_resource, password, user, 0)

        win32wnet.WNetCancelConnection2(share, 0, True)

        return True

    except pywintypes.error as e:

        print(f"Erro na conexão com o compartilhamento: {e}")

        return False

  

def get_file_type(filename):

    """Retorna uma string representando o tipo do arquivo, com base na extensão."""

    ext = filename.rsplit('.', 1)[-1].lower()

    if ext in ['pdf']:

        return 'pdf'

    elif ext in ['doc', 'docx']:

        return 'word'

    elif ext in ['xls', 'xlsx']:

        return 'excel'

    elif ext in ['ppt', 'pptx']:

        return 'powerpoint'

    elif ext in ['png', 'jpg', 'jpeg', 'gif']:

        return 'image'

    elif ext in ['txt']:

        return 'text'

    else:

        return 'other'

  

def get_icon_for_file(filename):

    """Retorna a classe do ícone FontAwesome correspondente ao arquivo."""

    ext = filename.rsplit('.', 1)[-1].lower()

    if ext in ['pdf']:

        return 'fas fa-file-pdf'

    elif ext in ['doc', 'docx']:

        return 'fas fa-file-word'

    elif ext in ['xls', 'xlsx']:

        return 'fas fa-file-excel'

    elif ext in ['ppt', 'pptx']:

        return 'fas fa-file-powerpoint'

    elif ext in ['png', 'jpg', 'jpeg', 'gif']:

        return 'fas fa-file-image'

    elif ext in ['txt']:

        return 'fas fa-file-alt'

    else:

        return 'fas fa-file'

  

def load_key():

    """Carrega a chave de criptografia; se não existir, gera e salva."""

    if not os.path.exists(KEY_FILE):

        key = Fernet.generate_key()

        with open(KEY_FILE, 'wb') as f:

            f.write(key)

    else:

        with open(KEY_FILE, 'rb') as f:

            key = f.read()

    return key

  

def load_saved_credentials():

    """Retorna um dicionário com as credenciais salvas (por IP)."""

    if not os.path.exists(CRED_FILE):

        return {}

    try:

        key = load_key()

        fernet = Fernet(key)

        with open(CRED_FILE, 'rb') as f:

            data_encrypted = f.read()

        data_json = fernet.decrypt(data_encrypted).decode()

        return json.loads(data_json)

    except Exception as e:

        print(f"Erro ao ler credenciais salvas: {e}")

        return {}

  

def save_credentials_for_ip(ip, username, password, domain):

    """Salva/atualiza as credenciais para o IP informado."""

    creds = load_saved_credentials()

    creds[ip] = {

        'username': username,

        'password': password,

        'domain': domain

    }

    try:

        key = load_key()

        fernet = Fernet(key)

        data_json = json.dumps(creds)

        data_encrypted = fernet.encrypt(data_json.encode())

        with open(CRED_FILE, 'wb') as f:

            f.write(data_encrypted)

    except Exception as e:

        print(f"Erro ao salvar credenciais: {e}")

  

# ---------------- SEGURANÇA: Cabeçalhos HTTP (com 'unsafe-inline' liberado) ----------------

  

@app.after_request

def set_security_headers(response: Response):

    response.headers['Content-Security-Policy'] = (

        "default-src 'self'; "

        "script-src 'self' 'unsafe-inline' https://code.jquery.com https://cdn.jsdelivr.net https://stackpath.bootstrapcdn.com; "

        "style-src 'self' https://stackpath.bootstrapcdn.com https://cdnjs.cloudflare.com; "

        "font-src 'self' https://cdnjs.cloudflare.com; "

        "img-src 'self' data:;"

    )

    response.headers['X-Frame-Options'] = 'DENY'

    response.headers['X-Content-Type-Options'] = 'nosniff'

    response.headers['Referrer-Policy'] = 'no-referrer'

    return response

  

# ---------------- AUTO-LOGIN VIA IP (before_request) ----------------

  

@app.before_request

def auto_login_by_ip():

    if session.get('full_access'):

        return

    client_ip = request.remote_addr

    creds = load_saved_credentials()

    if client_ip in creds:

        saved = creds[client_ip]

        if verifica_acesso_rede(BASE_DIR, saved['username'], saved['password'], saved['domain']):

            session['full_access'] = True

            session['username'] = saved['username']

            log_action("info", f"Auto-login: IP {client_ip} autenticado automaticamente")

        else:

            session['full_access'] = False

  

# ---------------- ROTAS ----------------

  

@app.route('/login_cred', methods=['POST'])

def login_cred():

    username = request.form.get('username')

    password = request.form.get('password')

    domain = request.form.get('domain') or ''

    salvar = request.form.get('salvar')

    current_path = request.form.get('current_path') or BASE_DIR

    if verifica_acesso_rede(BASE_DIR, username, password, domain):

        session['full_access'] = True

        session['username'] = username

        flash("Autorização realizada com sucesso! Você possui acesso completo.")

        log_action("info", f"Login manual: Usuário {username} autenticado")

        if salvar:

            save_credentials_for_ip(request.remote_addr, username, password, domain)

            log_action("info", f"Credenciais salvas para o IP {request.remote_addr}")

    else:

        session['full_access'] = False

        flash("Não foi possível autorizar as credenciais. Acesso ficará limitado à visualização.")

        log_action("warning", f"Falha no login: Tentativa com usuário {username} do IP {request.remote_addr}")

    return redirect(url_for('list_folder', path=current_path))

  

@app.route('/logout')

def logout():

    session.clear()

    flash("Logout realizado.")

    log_action("info", "Logout efetuado pelo usuário")

    return redirect(url_for('list_folder', path=BASE_DIR))

  

@app.route('/folder', methods=['GET'])

def list_folder():

    folder_path = request.args.get('path', BASE_DIR)

    folder_path = urllib.parse.unquote(folder_path)

    if not is_allowed_path(folder_path):

        return "Acesso negado.", 403

    if not os.path.isdir(folder_path):

        return "Pasta não encontrada.", 404

  

    orderby = request.args.get('orderby', 'nome')

    order = request.args.get('order', 'asc')

    try:

        itens = os.listdir(folder_path)

    except Exception as e:

        return f"Erro ao acessar a pasta: {e}", 500

  

    entries = []

    for item in itens:

        full_path = os.path.join(folder_path, item)

        if os.path.isdir(full_path):

            entry = {

                'nome': item,

                'path': full_path,

                'tipo': 'pasta',

                'mod_date': datetime.datetime.fromtimestamp(os.path.getmtime(full_path)).strftime("%d/%m/%Y %H:%M:%S"),

                'mod_timestamp': os.path.getmtime(full_path),

                'size': f"{len(os.listdir(full_path))} itens",

                'file_type': 'folder',

                'icon_class': 'fas fa-folder text-warning'

            }

        else:

            try:

                mod_timestamp = os.path.getmtime(full_path)

            except Exception:

                mod_timestamp = 0

            mod_date_str = datetime.datetime.fromtimestamp(mod_timestamp).strftime("%d/%m/%Y %H:%M:%S")

            try:

                size_bytes = os.path.getsize(full_path)

                size = human_readable_size(size_bytes)

            except Exception:

                size = "-"

            file_type = get_file_type(item)

            icon_class = get_icon_for_file(item)

            entry = {

                'nome': item,

                'path': full_path,

                'tipo': 'arquivo',

                'mod_date': mod_date_str,

                'mod_timestamp': mod_timestamp,

                'size': size,

                'file_type': file_type,

                'icon_class': icon_class

            }

        entries.append(entry)

  

    # Ordenação

    if orderby == 'data':

        entries = sorted(entries, key=lambda x: x['mod_timestamp'], reverse=(order=='desc'))

    else:

        entries = sorted(entries, key=lambda x: x['nome'].lower(), reverse=(order=='desc'))

  

    parent_folder = None

    if os.path.abspath(folder_path) != os.path.abspath(BASE_DIR):

        parent_folder = os.path.dirname(folder_path)

        if not is_allowed_path(parent_folder):

            parent_folder = None

  

    full_access = session.get('full_access', False)

    log_action("info", f"Visualização: Pasta listada {folder_path}")

  

    html_template = '''

    <!doctype html>

    <html lang="pt-BR">

      <head>

        <meta charset="utf-8">

        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

        <title>Gerenciador de Arquivos</title>

        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">

        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

        <style>

          a { text-decoration: none; }

          .nome-verde { color: green; }

          .folder-name { font-weight: bold; font-size: 1.1em; }

          .action-buttons { margin-bottom: 15px; }

          #basketPanel { position: sticky; top: 20px; }

          @media (max-width: 768px) { #basketPanel { margin-top: 20px; } }

          @media (max-width: 576px) {

              .folder-name { font-size: 1em; }

              .fa-folder, .fa-file, .fa-edit { font-size: 1.2em; }

              .col-tipo, .col-tamanho, .col-data { display: none; }

          }

        </style>

      </head>

      <body>

        <div class="container-fluid mt-4">

          <div class="row">

            <!-- Área principal (8 col) -->

            <div class="col-md-8">

              <h1 class="mb-4">Gerenciador de Arquivos</h1>

              <div class="mb-3">

                {% if full_access %}

                  <span class="badge badge-success">Acesso Completo ({{ session.username }})</span>

                  <a href="{{ url_for('logout') }}" class="btn btn-sm btn-outline-danger ml-2">Logout</a>

                {% else %}

                  <span class="badge badge-secondary">Somente Visualização</span>

                  <button class="btn btn-sm btn-outline-primary ml-2" data-toggle="modal" data-target="#modalLogin">Autorizar Credenciais</button>

                {% endif %}

              </div>

              {% with messages = get_flashed_messages() %}

                {% if messages %}

                  <div class="alert alert-info">

                    {% for message in messages %}

                      <p>{{ message }}</p>

                    {% endfor %}

                  </div>

                {% endif %}

              {% endwith %}

              <!-- Filtros (nome e tipo) -->

              <div class="row mb-3">

                <div class="col-md-6">

                  <input type="text" id="searchInput" class="form-control" placeholder="Pesquisar pelo nome...">

                </div>

                <div class="col-md-6">

                  <select id="fileTypeFilter" class="form-control">

                    <option value="all">Todos</option>

                    <option value="folder">Pastas</option>

                    <option value="pdf">PDF</option>

                    <option value="word">Word</option>

                    <option value="excel">Excel</option>

                    <option value="powerpoint">PowerPoint</option>

                    <option value="image">Imagem</option>

                    <option value="text">Texto</option>

                    <option value="other">Outros</option>

                  </select>

                </div>

              </div>

              {% if parent_folder %}

              <a href="{{ url_for('list_folder') }}?path={{ parent_folder|urlencode }}&orderby={{ orderby }}&order={{ order }}" class="btn btn-secondary mb-3">

                <i class="fas fa-arrow-left"></i> Voltar

              </a>

              {% endif %}

              <div class="card">

                <div class="card-header"><strong>{{ folder_path }}</strong></div>

                <div class="card-body">

                  {% if full_access %}

                  <div class="alert alert-secondary d-flex justify-content-end action-buttons mb-3" role="alert">

                    <button class="btn btn-primary mr-2" id="btnUploadAlert">Adicionar Arquivo</button>

                    <button class="btn btn-secondary" id="btnCreateFolderAlert">Criar Pasta</button>

                  </div>

                  {% else %}

                  <div class="alert alert-info mb-3" role="alert">

                    Você está em modo somente visualização. Para acessar todas as funcionalidades, autorize suas credenciais.

                  </div>

                  {% endif %}

                  <div class="table-responsive">

                    <table class="table table-hover">

                      <thead>

                        <tr>

                          <th>

                            <a href="{{ url_for('list_folder') }}?path={{ folder_path|urlencode }}&orderby=nome&order={% if orderby=='nome' and order=='asc' %}desc{% else %}asc{% endif %}">

                              Nome

                              {% if orderby=='nome' %}

                                {% if order=='asc' %}

                                  <i class="fas fa-sort-up"></i>

                                {% else %}

                                  <i class="fas fa-sort-down"></i>

                                {% endif %}

                              {% endif %}

                            </a>

                          </th>

                          <th class="col-tipo">Tipo</th>

                          <th class="col-tamanho">Tamanho</th>

                          <th class="col-data">Data de modificação</th>

                          <th>Ações</th>

                        </tr>

                      </thead>

                      <tbody>

                        {% for entry in entries %}

                        <tr data-file-type="{{ entry.file_type }}">

                          <td>

                            {% if entry.tipo == 'pasta' %}

                              <i class="{{ entry.icon_class }}"></i>

                              <a class="nome-verde folder-name" href="{{ url_for('list_folder') }}?path={{ entry.path|urlencode }}&orderby={{ orderby }}&order={{ order }}">{{ entry.nome }}</a>

                            {% else %}

                              <i class="{{ entry.icon_class }} text-secondary"></i>

                              <a class="nome-verde" href="{{ url_for('serve_file') }}?path={{ entry.path|urlencode }}" target="_blank">{{ entry.nome }}</a>

                            {% endif %}

                          </td>

                          <td class="col-tipo">{{ entry.tipo }}</td>

                          <td class="col-tamanho">{{ entry.size }}</td>

                          <td class="col-data">{{ entry.mod_date }}</td>

                          <td>

                            {% if entry.tipo == 'arquivo' %}

                              <!-- Botão adicionar à cesta -->

                              <button class="btn btn-sm btn-outline-success btn-add-basket"

                                      data-name="{{ entry.nome }}"

                                      data-path="{{ entry.path }}"

                                      title="Adicionar à cesta">

                                <i class="fas fa-plus"></i>

                              </button>

                            {% endif %}

                            {% if full_access %}

                              <!-- Botão renomear (acesso completo) -->

                              <button class="btn btn-sm btn-outline-primary rename-btn"

                                      data-oldname="{{ entry.nome }}"

                                      data-currentpath="{{ folder_path }}"

                                      title="Renomear">

                                <i class="fas fa-edit"></i>

                              </button>

                            {% endif %}

                          </td>

                        </tr>

                        {% endfor %}

                      </tbody>

                    </table>

                  </div>

                </div>

              </div>

            </div>

            <!-- Painel lateral: Cesta de Downloads (4 col) -->

            <div class="col-md-4">

              <div id="basketPanel" class="card">

                <div class="card-header">Cesta de Downloads</div>

                <div class="card-body">

                  <div class="form-group">

                    <label for="basketName">Nome da Cesta:</label>

                    <input type="text" id="basketName" class="form-control" placeholder="Digite um nome para a cesta">

                  </div>

                  <ul id="basketList" class="list-group mb-3">

                    <li class="list-group-item">Cesta vazia.</li>

                  </ul>

                  <button id="downloadBasketBtn" class="btn btn-primary btn-block">Baixar Cesta (ZIP)</button>

                </div>

              </div>

              <!-- Formulário oculto para enviar a cesta -->

              <form id="basketForm" action="{{ url_for('download_basket') }}" method="POST" style="display:none;">

                <input type="hidden" name="basketData" id="basketData">

                <input type="hidden" name="basketName" id="basketFormName">

              </form>

            </div>

          </div>

        </div>

        <!-- Modal para autorização de credenciais (se não houver acesso completo) -->

        {% if not full_access %}

        <div class="modal fade" id="modalLogin" tabindex="-1" role="dialog" aria-labelledby="modalLoginLabel" aria-hidden="true">

          <div class="modal-dialog modal-sm" role="document">

            <div class="modal-content">

              <form action="{{ url_for('login_cred') }}" method="POST">

                <div class="modal-header">

                  <h5 class="modal-title" id="modalLoginLabel">Autorizar Credenciais</h5>

                  <button type="button" class="close" data-dismiss="modal" aria-label="Fechar">

                    <span aria-hidden="true">&times;</span>

                  </button>

                </div>

                <div class="modal-body">

                  <div class="form-group">

                    <label for="username">Usuário:</label>

                    <input type="text" name="username" id="username" class="form-control" required>

                  </div>

                  <div class="form-group">

                    <label for="domain">Domínio (se aplicável):</label>

                    <input type="text" name="domain" id="domain" class="form-control">

                  </div>

                  <div class="form-group">

                    <label for="password">Senha:</label>

                    <input type="password" name="password" id="password" class="form-control" required>

                  </div>

                  <div class="form-group form-check">

                    <input type="checkbox" class="form-check-input" name="salvar" id="salvar">

                    <label class="form-check-label" for="salvar">Salvar credenciais neste computador</label>

                  </div>

                  <input type="hidden" name="current_path" value="{{ folder_path }}">

                </div>

                <div class="modal-footer">

                  <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>

                  <button type="submit" class="btn btn-primary">Autorizar</button>

                </div>

              </form>

            </div>

          </div>

        </div>

        {% endif %}

        {% if full_access %}

        <!-- Modal de Upload -->

        <div class="modal fade" id="uploadModal" tabindex="-1" role="dialog" aria-labelledby="uploadModalLabel" aria-hidden="true">

          <div class="modal-dialog modal-sm" role="document">

            <div class="modal-content">

              <div class="modal-header">

                <h5 class="modal-title" id="uploadModalLabel">Adicionar Arquivo</h5>

                <button type="button" class="close" data-dismiss="modal" aria-label="Fechar">

                  <span aria-hidden="true">&times;</span>

                </button>

              </div>

              <div class="modal-body">

                <form class="confirmable" action="{{ url_for('upload_file') }}" method="POST" enctype="multipart/form-data">

                  <div class="form-group">

                    <label for="fileInput">Selecione o arquivo</label>

                    <input type="file" class="form-control" id="fileInput" name="file" required>

                  </div>

                  <input type="hidden" name="current_path" value="{{ folder_path }}">

                  <button type="submit" class="btn btn-success btn-block">Enviar</button>

                </form>

              </div>

            </div>

          </div>

        </div>

        <!-- Modal de Criar Pasta -->

        <div class="modal fade" id="createFolderModal" tabindex="-1" role="dialog" aria-labelledby="createFolderModalLabel" aria-hidden="true">

          <div class="modal-dialog modal-sm" role="document">

            <div class="modal-content">

              <div class="modal-header">

                <h5 class="modal-title" id="createFolderModalLabel">Criar Pasta</h5>

                <button type="button" class="close" data-dismiss="modal" aria-label="Fechar">

                  <span aria-hidden="true">&times;</span>

                </button>

              </div>

              <div class="modal-body">

                <form class="confirmable" action="{{ url_for('create_folder') }}" method="POST">

                  <div class="form-group">

                    <label for="folderName">Nome da nova pasta</label>

                    <input type="text" class="form-control" id="folderName" name="folder_name" required>

                  </div>

                  <input type="hidden" name="current_path" value="{{ folder_path }}">

                  <button type="submit" class="btn btn-success btn-block">Criar Pasta</button>

                </form>

              </div>

            </div>

          </div>

        </div>

        <!-- Modal de Renomear -->

        <div class="modal fade" id="renameModal" tabindex="-1" role="dialog" aria-labelledby="renameModalLabel" aria-hidden="true">

          <div class="modal-dialog modal-sm" role="document">

            <div class="modal-content">

              <div class="modal-header">

                <h5 class="modal-title" id="renameModalLabel">Renomear</h5>

                <button type="button" class="close" data-dismiss="modal" aria-label="Fechar">

                  <span aria-hidden="true">&times;</span>

                </button>

              </div>

              <div class="modal-body">

                <form class="confirmable" id="renameForm" action="{{ url_for('rename_item') }}" method="POST">

                  <div class="form-group">

                    <label for="newNameInput">Novo nome</label>

                    <input type="text" class="form-control" id="newNameInput" name="new_name" required>

                  </div>

                  <input type="hidden" name="current_path" id="renameCurrentPath">

                  <input type="hidden" name="old_name" id="renameOldName">

                  <button type="submit" class="btn btn-success btn-block">Renomear</button>

                </form>

              </div>

            </div>

          </div>

        </div>

        {% endif %}

        <!-- Scripts (inline liberado por 'unsafe-inline') -->

        <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>

        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>

        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

        <script>

          console.log("JS carregado. Iniciando...");

  

          function filterRows() {

            console.log("Filtrando...");

            var searchValue = $("#searchInput").val().toLowerCase().trim();

            var fileTypeValue = $("#fileTypeFilter").val().toLowerCase().trim();

            $("table.table-hover tbody tr").each(function() {

              var fileName = $(this).find("a.nome-verde").text().toLowerCase().trim();

              var rowType = $(this).data("file-type") || "";

              rowType = rowType.toLowerCase().trim();

              var matchesSearch = fileName.indexOf(searchValue) > -1;

              var matchesType = (fileTypeValue === "all") || (rowType === fileTypeValue);

              $(this).toggle(matchesSearch && matchesType);

            });

          }

  

          $(document).ready(function(){

            console.log("Documento pronto, configurando eventos...");

  

            $("#searchInput").on("keyup", filterRows);

            $("#fileTypeFilter").on("change", filterRows);

  

            $("#btnUploadAlert").on("click", function(e) {

              e.preventDefault();

              $("#uploadModal").modal('show');

            });

            $("#btnCreateFolderAlert").on("click", function(e) {

              e.preventDefault();

              $("#createFolderModal").modal('show');

            });

            $(".rename-btn").on("click", function(e) {

              e.preventDefault();

              var oldName = $(this).data("oldname");

              var currentPath = $(this).data("currentpath");

              $("#renameOldName").val(oldName);

              $("#renameCurrentPath").val(currentPath);

              $("#newNameInput").val(oldName);

              $("#renameModal").modal('show');

            });

            // Cesta de downloads

            var basket = [];

            function updateBasketUI() {

              console.log("Atualizando UI da cesta...", basket);

              $("#basketList").empty();

              if (basket.length === 0) {

                $("#basketList").append("<li class='list-group-item'>Cesta vazia.</li>");

              } else {

                basket.forEach(function(item, index) {

                  $("#basketList").append(

                    "<li class='list-group-item d-flex justify-content-between align-items-center'>" +

                      "<span class='basket-item-name' data-index='" + index + "'>" + item.name + "</span>" +

                      "<div>" +

                        "<button type='button' class='btn btn-warning btn-sm rename-basket' data-index='" + index + "' title='Renomear'><i class='fas fa-edit'></i></button> " +

                        "<button type='button' class='btn btn-danger btn-sm remove-basket' data-index='" + index + "' title='Remover'><i class='fas fa-trash'></i></button>" +

                      "</div>" +

                    "</li>"

                  );

                });

              }

            }

            $(document).on("click", ".btn-add-basket", function(e) {

              e.preventDefault();

              var fileName = $(this).data("name");

              var filePath = $(this).data("path");

              console.log("Adicionando à cesta:", fileName, filePath);

              var exists = basket.some(function(item){ return item.path === filePath; });

              if (!exists) {

                basket.push({ name: fileName, path: filePath });

                updateBasketUI();

              } else {

                alert("Arquivo já está na cesta.");

              }

            });

            $(document).on("click", ".remove-basket", function(e) {

              e.preventDefault();

              var index = $(this).data("index");

              basket.splice(index, 1);

              updateBasketUI();

            });

            $(document).on("click", ".rename-basket", function(e) {

              e.preventDefault();

              var index = $(this).data("index");

              var currentName = basket[index].name;

              var newName = prompt("Digite o novo nome para este item:", currentName);

              if (newName && newName.trim() !== "") {

                basket[index].name = newName.trim();

                updateBasketUI();

              }

            });

            $("#downloadBasketBtn").on("click", function(e) {

              if (basket.length === 0) {

                alert("A cesta está vazia.");

                return;

              }

              var basketName = $("#basketName").val().trim() || "cesta";

              $("#basketFormName").val(basketName);

              $("#basketData").val(JSON.stringify(basket));

              $("#basketForm").submit();

            });

            $(".confirmable").on("submit", function(e) {

              if(!window.confirm("Tem certeza de que deseja executar esta ação?")){

                e.preventDefault();

              }

            });

            console.log("Início concluído.");

          });

        </script>

      </body>

    </html>

    '''

  

    return render_template_string(html_template,

                                  folder_path=folder_path,

                                  entries=entries,

                                  parent_folder=parent_folder,

                                  orderby=orderby,

                                  order=order,

                                  full_access=full_access)

  

@app.route('/file')

def serve_file():

    file_path = request.args.get('path')

    if not file_path:

        return "Nenhum arquivo informado.", 400

    file_path = urllib.parse.unquote(file_path)

    if not is_allowed_path(file_path):

        return "Acesso negado.", 403

    if not os.path.isfile(file_path):

        return "Arquivo não encontrado.", 404

    try:

        log_action("info", f"Download: Arquivo acessado {file_path}")

        return send_file(file_path)

    except Exception as e:

        log_action("error", f"Erro ao enviar arquivo {file_path}: {e}")

        return f"Erro ao enviar o arquivo: {e}", 500

  

def exige_acesso_completo():

    if not session.get('full_access'):

        flash("Ação não permitida em modo somente visualização. Autorize suas credenciais para acesso completo.")

        return False

    return True

  

@app.route('/upload', methods=['POST'])

def upload_file():

    current_path = request.form.get('current_path')

    if not exige_acesso_completo():

        return redirect(url_for('list_folder', path=current_path or BASE_DIR))

    if not current_path or not os.path.isdir(current_path):

        flash("Caminho inválido para upload.")

        return redirect(url_for('list_folder', path=BASE_DIR))

    if 'file' not in request.files:

        flash("Nenhum arquivo selecionado.")

        return redirect(url_for('list_folder', path=current_path))

    file = request.files['file']

    if file.filename == '':

        flash("Nenhum arquivo selecionado.")

        return redirect(url_for('list_folder', path=current_path))

    if file and allowed_file(file.filename):

        filename = secure_filename(file.filename)

        save_path = os.path.join(current_path, filename)

        try:

            file.save(save_path)

            flash("Arquivo enviado com sucesso!")

            log_action("info", f"Upload: Arquivo enviado {save_path}")

        except Exception as e:

            flash(f"Erro ao salvar o arquivo: {e}")

            log_action("error", f"Erro no upload do arquivo {filename}: {e}")

    else:

        flash("Tipo de arquivo não permitido.")

    return redirect(url_for('list_folder', path=current_path))

  

@app.route('/create_folder', methods=['POST'])

def create_folder():

    current_path = request.form.get('current_path')

    if not exige_acesso_completo():

        return redirect(url_for('list_folder', path=current_path or BASE_DIR))

    folder_name = request.form.get('folder_name')

    if not current_path or not os.path.isdir(current_path):

        flash("Caminho inválido para criar pasta.")

        return redirect(url_for('list_folder', path=BASE_DIR))

    if not folder_name:

        flash("Nome da pasta é obrigatório.")

        return redirect(url_for('list_folder', path=current_path))

    new_folder_path = os.path.join(current_path, folder_name)

    try:

        os.mkdir(new_folder_path)

        flash("Pasta criada com sucesso!")

        log_action("info", f"Criar Pasta: Pasta criada {new_folder_path}")

    except Exception as e:

        flash(f"Erro ao criar a pasta: {e}")

        log_action("error", f"Erro ao criar pasta {new_folder_path}: {e}")

    return redirect(url_for('list_folder', path=current_path))

  

@app.route('/rename', methods=['POST'])

def rename_item():

    current_path = request.form.get('current_path')

    if not exige_acesso_completo():

        return redirect(url_for('list_folder', path=current_path or BASE_DIR))

    old_name = request.form.get('old_name')

    new_name = request.form.get('new_name')

    if not current_path or not os.path.isdir(current_path):

        flash("Caminho inválido para renomear.")

        return redirect(url_for('list_folder', path=BASE_DIR))

    if not old_name or not new_name:

        flash("Nome antigo ou novo não informado.")

        return redirect(url_for('list_folder', path=current_path))

    old_path = os.path.join(current_path, old_name)

    new_path = os.path.join(current_path, new_name)

    try:

        os.rename(old_path, new_path)

        flash("Renomeado com sucesso!")

        log_action("info", f"Renomear: De {old_path} para {new_path}")

    except Exception as e:

        flash(f"Erro ao renomear: {e}")

        log_action("error", f"Erro ao renomear de {old_path} para {new_path}: {e}")

    return redirect(url_for('list_folder', path=current_path))

  

@app.route('/download_basket', methods=['POST'])

def download_basket():

    basket_data = request.form.get("basketData")

    basket_name = request.form.get("basketName") or "cesta"

    try:

        files = json.loads(basket_data)

    except Exception as e:

        flash("Erro ao ler os dados da cesta: " + str(e))

        return redirect(url_for('list_folder', path=BASE_DIR))

    if not files:

        flash("A cesta está vazia.")

        return redirect(url_for('list_folder', path=BASE_DIR))

    mem_zip = io.BytesIO()

    with zipfile.ZipFile(mem_zip, mode="w", compression=zipfile.ZIP_DEFLATED) as zf:

        for file_item in files:

            file_path = file_item.get("path")

            file_name = file_item.get("name")

            if not is_allowed_path(file_path) or not os.path.isfile(file_path):

                continue

            zf.write(file_path, arcname=file_name)

    mem_zip.seek(0)

    # Correção: usar 'download_name' em vez de 'attachment_filename'

    return send_file(mem_zip, mimetype="application/zip", as_attachment=True, download_name=f"{basket_name}.zip")

  

if __name__ == '__main__':

    app.run(host='0.0.0.0', port=5000, debug=True)
```
